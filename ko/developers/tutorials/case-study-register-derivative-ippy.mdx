---
title: "사례 연구: Ippy의 파생작 등록하기"
description: Story의 공식 마스코트 Ippy의 파생작을 등록하는 생성형 pfp 프로젝트 PiPi의 사례 연구
---

[PiPi](https://pfp3.io/pipi/mint)는 Story에서 [Ippy](https://explorer.story.foundation/ipa/0xB1D831271A68Db5c18c8F0B69327446f7C8D0A42), Story의 공식 마스코트의 파생 작품을 민팅할 수 있는 무료 생성형 pfp 프로젝트입니다. Ippy에는 [Non-Commercial Social Remixing (NCSR)](/concepts/programmable-ip-license/pil-flavors#flavor-%231%3A-non-commercial-social-remixing) 조건이 적용되어 있어, 상업적으로 사용하지 않고 적절한 출처를 표시하는 한 누구나 사용하거나 파생 작품을 만들 수 있습니다.

<CardGroup cols={3}>
  <Card title="Original Ippy" href="https://explorer.story.foundation/ipa/0xB1D831271A68Db5c18c8F0B69327446f7C8D0A42" icon="house">
    우리의 익스플로러에서 원본 Ippy 마스코트를 확인하세요.
  </Card>

  {" "}

  <Card title="PiPi Derivative" href="https://explorer.story.foundation/ipa/0xBB42BF2713ee736284C45B1b549a03625cc97e51" icon="house">
    우리의 익스플로러에서 PiPi 파생작을 확인하세요.
  </Card>

  <Card title="View PiPi Contract" href="https://www.storyscan.io/address/0x5C6b236A100d09f8A625dB87E11122749A9B71A6?tab=contract" icon="scroll">
    PiPi 컨트랙트 소스 코드를 확인하세요.
  </Card>
</CardGroup>

PiPi가 Ippy의 파생작으로 연결되면, 자동으로 동일한 라이선스 조건(NCSR)을 상속받고 계보도에 연결되며, 이는 우리의 익스플로러에서 직접 확인할 수 있습니다:

<Frame caption="In the bottom right, you can see Ippy is the root IP of this PiPi.">
  <img src="/images/tutorials/pippy-explorer.png" alt="In the bottom right, you can see Ippy is the root IP of this PiPi." />
</Frame>

다음 튜토리얼에서는 이러한 PiPi 이미지들이 공식 Ippy IP의 파생작으로 어떻게 정확히 등록되었는지 배우게 됩니다.

## 전제 조건

튜토리얼을 시작하기 전에 완료해야 할 몇 가지 단계가 있습니다.

1. 다음을 완료하세요 [자신의 프로젝트 설정하기](/developers/smart-contracts-guide/setup)

## 1. 메타데이터 설정

새로운 PiPi IP를 등록하기 전에 메타데이터를 설정해야 합니다. 메타데이터에는 두 가지 유형이 있습니다:

1. NFT 메타데이터
2. IP 메타데이터

<CardGroup cols={1}>
  <Card title="NFT vs. IP Metadata" href="/concepts/ip-asset/overview#nft-vs-ip-metadata" icon="house">
    NFT와 IP 메타데이터를 올바르게 설정하는 방법을 알아보세요.
  </Card>
</CardGroup>

다음 [PiPi](https://explorer.story.foundation/ipa/0xBB42BF2713ee736284C45B1b549a03625cc97e51)를 예시로 들어, NFT와 IP 메타데이터는 다음과 같아야 합니다:

<CodeGroup>
  ```json NFT Metadata
  {
    "name": "PiPi NFT #1103",
    "image": "https://ipfs.io/ipfs/bafybeigsv4cgacndijwy6b7qhxbseonrybrcpbh47zrlm64gsjm4mlpb2q/nft_1103.jpeg",
    "attributes": [
      {
        "trait_type": "Bg",
        "value": "Orange"
      },
      {
        "trait_type": "Body",
        "value": "Pink"
      },
      {
        "trait_type": "Eyes",
        "value": "Cute"
      },
      {
        "trait_type": "Cloth",
        "value": "Blue"
      },
      {
        "trait_type": "Glasses",
        "value": "Neo"
      },
      {
        "trait_type": "Hat",
        "value": "Duck"
      }
    ],
    "description": "Pipi - The first Derivative IP Asset NFT collection on Story Protocol. Limited 2222 generative PFPs inspired by the Ippy, official Story mascot."
  }
  ```

  ```json IP Metadata
  {
    "title": "PiPi NFT",
    "description": "Pipi - The first Derivative IP Asset NFT collection on Story Protocol. Limited 2222 generative PFPs inspired by the Ippy, official Story mascot.",
    "image": "https://ipfs.io/ipfs/bafybeigsv4cgacndijwy6b7qhxbseonrybrcpbh47zrlm64gsjm4mlpb2q/nft_1103.jpeg",
    "imageHash": "0xb930f3ba19350bddbcd8c180a3127086f6e454d29cd5b3db613c70bae2848329",
    "mediaUrl": "https://ipfs.io/ipfs/bafybeigsv4cgacndijwy6b7qhxbseonrybrcpbh47zrlm64gsjm4mlpb2q/nft_1103.jpeg",
    "mediaHash": "0xb930f3ba19350bddbcd8c180a3127086f6e454d29cd5b3db613c70bae2848329",
    "mediaType": "image/jpeg",
    "creators": [
      {
        "name": "PFP3",
        "address": "0xF91510A17392Be6B3b6F620427051168A1e56A72",
        "description": "PFP Generator",
        "image": "https://utfs.io/f/XyGBmmuHQK18FodS0WDuqCo1LVerXR7sgm8vJnESazWcM5yB",
        "socialMedia": [
          {
            "platform": "twitter",
            "url": "https://x.com/pfp3_"
          },
          {
            "platform": "website",
            "url": "https://pfp3.io"
          },
          {
            "platform": "discord",
            "url": "https://discord.gg/pfp3"
          }
        ],
        "role": "creator",
        "contributionPercent": 100
      }
    ],
    "tags": ["PiPi", "Derivative IPA", "NFT", "PF3", "PFP"],
    "ipType": "NFT"
  }
  ```
</CodeGroup>

메타데이터를 작성한 후에는 IPFS에 업로드하고 나중에 NFT를 민팅할 때 설정할 수 있습니다.

## 2. NFT 민팅하기

Story에서 IP를 등록하려면 먼저 NFT를 민팅해야 합니다. 이 NFT는 **소유권**을 나타내는 [IP Asset](/concepts/ip-asset)입니다.

<CardGroup cols={1}>
  <Card title="View PiPi Contract" href="https://www.storyscan.io/address/0x5C6b236A100d09f8A625dB87E11122749A9B71A6?tab=contract" icon="scroll">
    PiPi 컨트랙트 소스 코드를 확인하세요.
  </Card>
</CardGroup>

다음은 `_mintNFT` 함수의 일부입니다 `PiPi.sol` contract:

```sol PiPi.sol
contract PiPi is ERC721, Ownable, IERC721Receiver {

  // ... some code here ...

  function whitelistMint() external payable returns (string memory, address) {
    require(whitelistMintEnabled, "Whitelist mint is not active");
    require(whitelist[msg.sender], "Address not whitelisted");
    require(mintedCount[msg.sender] < WHITELIST_MAX_P_WALLET, "Whitelist mint limit reached");
    require(_totalSupply < MAX_SUPPLY, "Max supply reached");

    return _mintNFT(msg.sender);
  }

  function _mintNFT(address recipient) internal returns (string memory, address) {
    uint256 newTokenId = _totalSupply + 1;
    _safeMint(address(this), newTokenId);

    address ipId = _registerAsIPAsset(newTokenId);

    string memory nftUri = tokenURI(newTokenId);
    bytes32 metadataHash = keccak256(abi.encodePacked(nftUri));
    CORE_METADATA_MODULE.setAll(ipId, nftUri, metadataHash, metadataHash);

    registerDerivativeForToken(ipId);

    _safeTransfer(address(this), recipient, newTokenId, "");

    // ... more code here ...

    return (nftUri, ipId);
  }
}
```

보시다시피, 사용자가 `whitelistMint`를 호출하면 `_mintNFT`를 호출하여 사용자가 화이트리스트에 있는지 확인합니다. 16번째 줄에서 컨트랙트에 새로운 NFT를 민팅합니다.

<Note>
  **왜 NFT를 사용자가 아닌 컨트랙트에 민팅하나요?**

  나중에 IP를 Ippy의 파생작으로 등록해야 합니다. 오직 소유자(NFT를 보유한 주소)만이 IP를 다른 IP의 파생작으로 등록할 수 있습니다. 따라서 NFT를 컨트랙트에 민팅 => 컨트랙트가 NFT를 IP로 등록하고 나중에 Ippy의 파생작으로 등록 => NFT를 사용자에게 전송하는 순서로 진행됩니다.
</Note>

## 3. NFT를 IP로 등록하기

새로운 NFT를 민팅한 후에는 이를 IP로 등록할 수 있습니다. 위의 18번째 줄에서는 `_registerAsIPAsset` function:

```sol PiPi.sol
function _registerAsIPAsset(uint256 tokenId) internal returns (address) {
  try IP_ASSET_REGISTRY.register(block.chainid, address(this), tokenId) returns (address ipId) {
    require(ipId != address(0), "IP Asset registration failed");
    return ipId;
  } catch Error(string memory reason) {
    revert(reason);
  } catch {
    revert("IP Asset registration failed");
  }
}
```

이것은 단순히 `register` 함수를 [IP Asset Registry](/concepts/registry/ip-asset-registry)에서 호출하여 새로운 [IP Asset](/concepts/ip-asset)을 우리 프로토콜에 생성하고 `ipId`를 반환합니다.

## 4. IP에 메타데이터 설정하기

이제 새로운 IP Asset을 등록했으니, 이전에 만든 메타데이터를 `CoreMetadataModule.sol`를 사용하여 NFT와 IP에 설정할 수 있습니다. [여기](/concepts/ip-asset/overview#adding-nft-%26-ip-metadata-to-ip-asset)에서 설명한 대로, 4개의 매개변수를 설정해야 합니다:

1. `nftMetadataHash`
2. `nftMetadataURI`
3. `ipMetadataHash`
4. `ipMetadataURI`

```sol PiPi.sol
// handles the NFT's `nftMetadataHash`
// handles the IP's `ipMetadataURI` and `ipMetadataHash`
function _mintNFT(address recipient) internal returns (string memory, address) {

  // ... some code here ...

  string memory nftUri = tokenURI(newTokenId);
  bytes32 metadataHash = keccak256(abi.encodePacked(nftUri));
  CORE_METADATA_MODULE.setAll(ipId, nftUri, metadataHash, metadataHash);

  // ... some code here ...

}

// handles the NFT's `nftMetadataURI`
function tokenURI(uint256 tokenId) public view override returns (string memory) {
  return string(abi.encodePacked(_baseUri, StringUtils.uint2str(tokenId), ".json"));
}
```

## 5. 파생작으로 등록하기

이제 NFT를 민팅하고, IP로 등록하고, 적절한 메타데이터를 설정했으니 Ippy의 파생작으로 등록할 수 있습니다. `PiPi.sol` 컨트랙트는 `registerDerivativeForToken` 이를 처리하기 위해:

```sol PiPi.sol
function registerDerivativeForToken(address ipId) internal {
  address[] memory parentIpIds = new address[](1);
  parentIpIds[0] = 0xB1D831271A68Db5c18c8F0B69327446f7C8D0A42;

  uint256[] memory licenseTermsIds = new uint256[](1);
  licenseTermsIds[0] = 1;

  address licenseTemplate = 0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316;
  bytes memory royaltyContext = hex"0000000000000000000000000000000000000000";
  uint256 maxMintingFee = 0;
  uint32 maxRts = 0;
  uint32 maxRevenueShare = 0;

  LICENSING_MODULE.registerDerivative(
    ipId,
    parentIpIds,
    licenseTermsIds,
    licenseTemplate,
    royaltyContext,
    maxMintingFee,
    maxRts,
    maxRevenueShare
  );
}
```

이 함수는 `registerDerivative` 에서 [Licensing Module](/concepts/licensing-module)을 호출하며:

* `ipId`: 새로운 `ipId` 3단계에서 얻은 것
* `parentIpIds`: Ippy의 `ipId`인 `0xB1D831271A68Db5c18c8F0B69327446f7C8D0A42`
* `licenseTermsIds`: 배열에 포함된 `1`, 이는 라이선스 조건 ID인 [Non-Commercial Social Remixing (NCSR)](/concepts/programmable-ip-license/pil-flavors#flavor-%231%3A-non-commercial-social-remixing). 이는 파생작이 Ippy를 무료로 사용할 수 있지만 상업화할 수 없다는 의미입니다
* `licenseTemplate`: 주소는 `PILicenseTemplate`, 위치는 [Deployed Smart Contracts](/developers/deployed-smart-contracts)
* `royaltyContext`: 제로 주소로 설정
* `maxMintingFee`, `maxRts`, 그리고 `maxRevenueShare` 는 0으로 설정할 수 있습니다. 라이선스 조건이 비상업적이기 때문에 아무 영향이 없습니다.

## 6. NFT 전송

이제 컨트랙트가 IP를 파생작으로 등록하는 것을 처리했으니, PiPi IP에 대한 소유권을 갖도록 NFT를 사용자에게 전송합니다:

```sol PiPi.sol
function _mintNFT(address recipient) internal returns (string memory, address) {
  // ... some code here ...
  _safeTransfer(address(this), recipient, newTokenId, "");
  // ... some code here ...
}
```

## 7. 완료!

축하합니다, 공식 Ippy IP의 파생작을 등록하셨습니다!

<CardGroup cols={2}>
  <Card title="View on Explorer" href="https://explorer.story.foundation/ipa/0xBB42BF2713ee736284C45B1b549a03625cc97e51" icon="house">
    우리의 탐색기에서 파생 PiPi를 확인하세요.
  </Card>

  <Card title="Learn More" href="/developers/tutorials" icon="book-open">
    문서에서 더 많은 튜토리얼을 살펴보세요
  </Card>
</CardGroup>
